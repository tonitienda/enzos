name: Run EnzOS Build And Tests
description: Pull or build images, run unit tests, build artifacts, and perform QEMU smoke testing.
inputs:
  build-image:
    description: Image name for the build environment.
    required: true
  build-tag:
    description: Tag to use when pulling the build image.
    required: true
  build-built:
    description: Whether the build image was built in the workflow run.
    required: true
  build-pushable:
    description: Whether the build image push is permitted for this event.
    required: true
  run-image:
    description: Image name for the run environment.
    required: true
  run-tag:
    description: Tag to use when pulling the run image.
    required: true
  run-built:
    description: Whether the run image was built in the workflow run.
    required: true
  run-pushable:
    description: Whether the run image push is permitted for this event.
    required: true
runs:
  using: composite
  steps:
    - name: Pull build and run images (with local fallback)
      shell: bash
      run: |
        set -euo pipefail

        pull_image() {
          local image="$1" tag="$2" built="$3" pushable="$4" alias="$5"

          if [ -z "$image" ]; then
            echo "Image name missing for $alias image" >&2
            return 1
          fi

          local ref
          if [ "$built" = "true" ] && [ "$pushable" = "true" ]; then
            ref="${image}:${tag}"
          else
            ref="${image}:latest"
          fi

          echo "Pulling $ref for $alias ..."
          if docker pull "$ref"; then
            docker tag "$ref" "$alias"
            return 0
          fi

          echo "Pull failed for $alias; will try to build locally." >&2
          return 1
        }

        build_image() {
          local alias="$1" dockerfile="$2" image="$3" tag="$4"
          echo "Building $alias from $dockerfile ..."
          docker build -f "$dockerfile" -t "$image:$tag" -t "$image:latest" .
          docker tag "$image:$tag" "$alias"
        }

        declare -A PIDS
        pull_image "${{ inputs.build-image }}" "${{ inputs.build-tag }}" "${{ inputs.build-built }}" "${{ inputs.build-pushable }}" enzos-build &
        PIDS[build]=$!
        pull_image "${{ inputs.run-image }}" "${{ inputs.run-tag }}" "${{ inputs.run-built }}" "${{ inputs.run-pushable }}" enzos-run &
        PIDS[run]=$!

        declare -A FAILED
        for key in "${!PIDS[@]}"; do
          if ! wait "${PIDS[$key]}"; then
            FAILED[$key]=1
          fi
        done

        if ! docker image inspect enzos-build >/dev/null 2>&1; then
          build_image enzos-build Dockerfile.build-env "${{ inputs.build-image }}" "${{ inputs.build-tag }}"
        fi

        if ! docker image inspect enzos-run >/dev/null 2>&1; then
          build_image enzos-run Dockerfile.run-env "${{ inputs.run-image }}" "${{ inputs.run-tag }}"
        fi

    - name: Verify build environment
      shell: bash
      run: docker run --rm enzos-build i686-elf-gcc --version

    - name: Verify run environment
      shell: bash
      run: docker run --rm enzos-run qemu-system-x86_64 --version

    - name: Run unit tests
      shell: bash
      run: |
        docker run --rm \
          -v "$PWD":/src \
          -w /src \
          enzos-build \
          bash -c "./scripts/run-tests.sh"

    - name: Build kernel ELF
      shell: bash
      run: |
        docker run --rm \
          -v "$PWD":/src \
          -w /src \
          enzos-build \
          bash -c "./scripts/build-elf.sh"

    - name: Build ISO
      shell: bash
      run: |
        docker run --rm \
          -v "$PWD":/src \
          -w /src \
          enzos-build \
          bash -c "./scripts/build-iso.sh"

    - name: Run smoke and integration tests inside container
      shell: bash
      run: |
        docker run --rm \
          -v "$PWD":/src \
          -w /src \
          enzos-run \
          bash -c '
            set -euo pipefail

            export QEMU_MONITOR_ADDR="${QEMU_MONITOR_ADDR:-127.0.0.1:45454}"
            export VNC_PORT="${VNC_PORT:-1}"

            QEMU_KEEP_ALIVE=true \
            QEMU_MONITOR_ADDR="$QEMU_MONITOR_ADDR" \
            VNC_SCREENSHOT=qemu-screen-smoke.ppm \
            VNC_CLIENT_LOG=qemu-vnc-client-smoke.log \
            QEMU_VNC_LOG=qemu-vnc-server.log \
            VNC_CAPTURE_MODE="${VNC_CAPTURE_MODE:-internal}" \
            VNC_WAIT_SECONDS="${VNC_WAIT_SECONDS:-5}" \
            ./scripts/qemu-smoketest.sh enzos.iso

            QEMU_MONITOR_ADDR="$QEMU_MONITOR_ADDR" \
            go test ./scripts -count=1 -v

            VNC_SCREENSHOT=qemu-screen-integration.ppm \
            VNC_CLIENT_LOG=qemu-vnc-client-integration.log \
            VNC_PORT="$VNC_PORT" \
            VNC_CONNECT_ADDR=127.0.0.1 \
            ./scripts/capture-vnc.sh

            VNC_SCREENSHOT=qemu-screen-integration-terminal.ppm \
            VNC_CLIENT_LOG=qemu-vnc-client-integration-terminal.log \
            VNC_PORT="$VNC_PORT" \
            VNC_CONNECT_ADDR=127.0.0.1 \
            VNC_WAIT_SECONDS=3 \
            ./scripts/capture-vnc.sh

            go run ./scripts/qemu_monitor_client.go -mode exec -addr "$QEMU_MONITOR_ADDR" -cmd quit || true
          '

    - name: Validate VGA dump artifacts
      if: always()
      shell: bash
      run: |
        set -euo pipefail

        if [[ ! -f qemu-vga-dump.raw.txt ]]; then
          echo "Missing qemu-vga-dump.raw.txt; smoke test did not produce a VGA dump." >&2
          exit 1
        fi

        VGA_TEXT=$(docker run --rm \
          -v "$PWD":/src \
          -w /src \
          enzos-run \
          bash -c "go run scripts/qemu_vga_extract.go qemu-vga-dump.raw.txt")

        if [[ "$VGA_TEXT" != *"EnzOS booted successfully."* ]]; then
          echo "Boot message not found in qemu-vga-dump.raw.txt: EnzOS booted successfully." >&2
          exit 1
        fi

    - name: Convert VNC screenshots to PNG
      if: always()
      shell: bash
      run: |
        docker run --rm \
          -v "$PWD":/src \
          -w /src \
          enzos-run \
          bash -c "if [[ -f qemu-screen-smoke.ppm ]]; then convert qemu-screen-smoke.ppm qemu-screen-smoke.png; fi; if [[ -f qemu-screen-integration.ppm ]]; then convert qemu-screen-integration.ppm qemu-screen-integration.png; fi; if [[ -f qemu-screen-integration-terminal.ppm ]]; then convert qemu-screen-integration-terminal.ppm qemu-screen-integration-terminal.png; fi"
